import{_ as i,M as l,p as c,q as r,R as n,N as s,V as p,t as a,a1 as t}from"./framework-7e1a102e.js";const u={},d={class:"table-of-contents"},k=t(`<p>[toc]</p><p>0.0.0.0 表示一个无效的，未知的或者不可用的目标 在服务器中，0.0.0.0 指的是本机上的所有 IPV4 地址，如果一个主机有两个 IP 地址，并且该主机上的一个服务监听的地址是 0.0.0.0,那么通过两个 ip 地址都能够访问该服务。 在路由中，0.0.0.0 表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。</p><p>127.0.0.1 属于{127,}集合中的一个，而所有网络号为 127 的地址都被称之为回环地址;大部分 Web 容器测试的时候绑定的本机地址</p><p>localhost 是个域名</p><h2 id="node-与-deno-异同" tabindex="-1"><a class="header-anchor" href="#node-与-deno-异同" aria-hidden="true">#</a> node 与 Deno 异同</h2><ul><li><p>node 为 js 的运行平台；Deno 为 js 和 ts 的运行平台</p></li><li><p>Deno 采用沙箱模式运行代码，某些权限需要配置添加</p></li></ul><hr><h2 id="后端认证方式" tabindex="-1"><a class="header-anchor" href="#后端认证方式" aria-hidden="true">#</a> 后端认证方式：</h2><ol><li>传统的 session 认证</li></ol><p>用户认证记录保存在内存中的话，用户下次请求必须要请求在这台服务器上,才能拿到授权的资源，服务端的开销会明显增大，这样在分布式的应用上，相应的限制了负载均衡器的能力</p><ol start="2"><li>基于 token 的鉴权</li></ol><p>不需要去考虑用户在哪一台服务器登录 ，客户端存储 token，并在每次请求时附送上这个 token 值 服务端验证 token 值，并返回数据 ；服务端要支持 CORS(跨来源资源共享)策略</p><ol start="3"><li>Json web token (JWT)</li></ol><p><code>Header.Payload.Signature</code> 三部分生成 token</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// Header 会被 base64 编码</span>
<span class="token punctuation">{</span>
  <span class="token string-property property">&#39;type&#39;</span><span class="token operator">:</span> <span class="token string">&#39;JWT&#39;</span><span class="token punctuation">,</span>
  <span class="token string-property property">&#39;alg&#39;</span><span class="token operator">:</span> <span class="token string">&#39;HS256&#39;</span> 算法
<span class="token punctuation">}</span>
<span class="token comment">// 会被base64编码</span>
<span class="token punctuation">{</span>
  <span class="token string-property property">&#39;sub&#39;</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span>
  <span class="token string-property property">&#39;name&#39;</span><span class="token operator">:</span><span class="token string">&#39;&#39;</span>
  <span class="token string-property property">&#39;admin&#39;</span><span class="token operator">:</span><span class="token boolean">true</span>
<span class="token punctuation">}</span>
<span class="token comment">// 签名：将各个部分编码后用 . 连接； 用的算法就是Header中的</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一种标准 特别适用于分布式站点的单点登录（用户只需要登录一次就可以访问所有相互信任的应用系统）</p><p>token 需要查库验证 token 是否有效，而 JWT 不用查库或者少查库</p><p>利用 secret 来加密和解密 所以千万不能泄露</p><h2 id="npm-shrinkwrap-json-和-package-lock-json-区别" tabindex="-1"><a class="header-anchor" href="#npm-shrinkwrap-json-和-package-lock-json-区别" aria-hidden="true">#</a> npm-shrinkwrap.json 和 package-lock.json 区别</h2><ul><li>shrinkwrap 向后兼容 npm 版本 2,3 和 4</li><li>package-lock 只能被 npm 5+识别</li><li>可以通过运行 npm shrinkwrap package-lock.json 将现有的 package-lock.json 转换为 npm-shrinkwrap.json</li><li>shrinkwrap 应该用于库来保证安装程序包的每个人都获得完全相同的所有依赖项版本</li><li>package-lock 允许安装程序包的人使用与 package.json 指定的版本范围兼容的任何版本的依赖项</li><li>npm install 操作会自动生成 package-lock 文件 并且更新该文件</li><li>如果是用的 cnpm 安装的包 注意要 npm install 操作一次 更新 package-lock 文件</li></ul><h2 id="package-json" tabindex="-1"><a class="header-anchor" href="#package-json" aria-hidden="true">#</a> package.json</h2><p>devdependencies 表示开发过程中依赖的包; dependencies 表示项目在生产环境中依赖的包</p><ul><li>尖括号只限大版本号: 比入^0.1.1,如果有小于 1.0.0 的版本都可自动更新，超过就保持 0.9.9</li><li>波浪号表示只监控最小版本号的更新（如~0.1.2,当有大于该版本号且小于 0.2.0 才更新）</li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token property">&quot;main&quot;</span><span class="token operator">:</span><span class="token string">&quot;&quot;</span> <span class="token comment">// 出口文件 默认根目录下 index.js</span>
<span class="token property">&quot;script&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
  <span class="token property">&quot;test&quot;</span><span class="token operator">:</span><span class="token string">&quot;grunt test&quot;</span>
<span class="token punctuation">}</span>
<span class="token property">&quot;engines&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
  <span class="token property">&quot;node&quot;</span><span class="token operator">:</span><span class="token string">&quot;&gt;=0.10.0&quot;</span>
<span class="token punctuation">}</span> <span class="token comment">//便是node版本需求</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>npm start 和 npm test 可以直接用；其它用 npm run</p><p>npm install 默认两个下的都安装，--production 只安装 dependences 的</p><hr><ul><li><p>如果不是安装在 c 盘需要设置环境变量</p></li><li><p>设置使用 es6 语法，package.json 设置 &quot;type&quot;: &quot;module&quot; 文件用 .mjs, 注意语法不用 es6 的话可能会报错</p></li></ul><h2 id="模块的分类" tabindex="-1"><a class="header-anchor" href="#模块的分类" aria-hidden="true">#</a> 模块的分类</h2><ol><li>一．核心模块</li><li>二．文件模块</li><li>三．第三方模块</li></ol><h2 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识" aria-hidden="true">#</a> 基础知识</h2><ul><li><p>p<wbr>rocess.env 为 node 的全局变量；设置 <code>p<wbr>rocess.env.some = &#39;value&#39;;</code></p></li><li><p>在 CommonJS 模块中加载 json 文件，只需通过 require()函数直接加载即可得到 json 对象</p></li></ul><p>node 中的 map()、forEach()、for()循环有一个特性：当其函数里面里面有回调它就变成异步</p><p>Node 里面没有全局命名空间的概念</p><p>url.parse(&#39;http://www.imooc.com/video/6710&#39;)</p><p>protocol:&#39;http:&#39;,表示底层的协议</p><p>slashes:true,有没有协议后面的双斜线;</p><p>host:ip 地址或是域名;</p><p>port:端口</p><p>hostname:主机名;</p><p>还可以加传两个参数</p><p>第二个参数:默认 false，设置为 true，就会用 queryString 来解析 query 的字符串，会将 query 的值解析为对象模式;</p><p>第三个参数:默认 false,设置为 true,就会对没有明确协议的 url 进行正确解析;</p><p>url.format({});生成一个 url 地址;</p><p>HTTP:</p><p>浏览器搜索自身 DNS 缓存，如果有就看有没有过期如果过期就结束，就开始搜索操作系统的 DNS 缓存，若也没有就读去本地 Host 文件，若也没有浏览器就会发起一个 DNS 系统调用（一般是运营商的），运营商服务器会产看自身的缓存，一直逐层请求解析 DNS</p><p>About:DNS</p><p>chrome://net-internals/#dns</p><hr><p>node 的全局对象 global 相当于浏览器中的 window</p><hr><p>cheerio 是 nodejs 的抓取页面模块，为服务器特别定制的，快速、灵活、实施的 jQuery 核心实现。适合各种 Web 爬虫程序。</p><hr><p>官方建议对一个事件不要设置超过十个监听器。太多的话可能会导致内存泄露（内存空间使用后没有收回）。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> eventsEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;events&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>EventEmitter<span class="token punctuation">;</span>
<span class="token keyword">var</span> life <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">eventsEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
life<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;e1&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">w</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;事件1是:&quot;</span> <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
life<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&quot;e1&quot;</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更改监听数量</p><p>life.setMaxListeners(数量);</p><p>查看是否被监听过</p><p>life.emit()会返回一个布尔 boolean 值;如果监听返回 true；移除某个事件</p><p>life.removeListener(&#39;事件名&#39;，具名函数名 f)</p><p>life.on(事件名，函数名 f);</p><p>批量移除</p><p>life.removeAllListeners(事件名);</p><p>某个事件的个数;</p><p>life.listeners(事件名).length 或</p><p>eventsEmitter.listenerCount(life（实例化）,事件名)</p><hr><p>path.join() 也可以用 <code>../</code></p><p><code>console.log(path.join(__dirname, &#39;a&#39;, &#39;b&#39;)) // C:\\folder1\\folder2\\a\\b</code></p><p>path.resolve() 任意一个参数是以<code>/</code>开头都直接转到根目录 <code>../</code> 是会在上一个参数的基础上返回上一级目录进行拼接</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// G:\\GitHub\\webpack-pure</span>
<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;a/b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// G:\\GitHub\\webpack-pure\\a\\b\\c</span>
<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;a/b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;/k&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// G:\\k</span>
<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;a/b/c&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;../m&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// G:\\GitHub\\webpack-pure\\a\\b\\m</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>path.resolve(&#39;./&#39;)：当前运行命令所在的目录</li><li>process.cwd()：当前运行命令所在的目录</li><li>path.sep // 平台特定的路径片段分隔符 (例如 windows 是: \\ )</li><li><code>__dirname</code> ：nodejs 的全局变量 返回文件所在的目录 <code>F:\\work\\xx\\yy</code></li><li><code>__filename</code> ：返回文件所在的目录和名称 <code>F:\\work\\xx\\yy\\file.js</code> <strong>获取文件名+后缀</strong> <code>filename.slice(__dirname.length + 1)</code></li><li>path.basename(<code>__dirname</code>, suffix) 返回地址的最后一部分</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">basename</span><span class="token punctuation">(</span><span class="token string">&#39;/aa/sss/vv/&#39;</span><span class="token punctuation">)</span> <span class="token comment">// vv</span>
<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">&#39;/aa/sss/vv&#39;</span><span class="token punctuation">)</span> <span class="token comment">// vv</span>
<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">&#39;/aa/sss/vv.js&#39;</span><span class="token punctuation">)</span> <span class="token comment">// vv.js</span>
<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token string">&#39;/aa/sss/vv.js&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;.js&#39;</span><span class="token punctuation">)</span> <span class="token comment">// vv  可用于获取文件名称</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>module.exports = exports = {} //是按照这个方式赋值</p><p>当先设置了 module.exports, <code>exports.属性</code> 将失效</p><p>require() 返回的是 module.exports</p><p>把一个对象封装到模块当中</p><p>module.exports=function(){<br> this.name=&#39;hew&#39;;<br> } //用 require 获取到的是一个函数方法</p><p>多个模块</p><p>exports.login=function(){} //用 require 获取到的是一个对象</p><p>如{<br> name:function{},login:function(){}<br> }</p><hr><p>exports 是模块公开的接口</p><p>require 用于从外部获取一个模块接口及获取模块的 exports 对象</p><hr><h2 id="常见的-content-type" tabindex="-1"><a class="header-anchor" href="#常见的-content-type" aria-hidden="true">#</a> 常见的 Content-Type</h2><p>application/x-www-form-urlebcoded 常见的 form 提交 post 提交时可以将 content-type 改为该值, 传统的表单提交</p><p>multipart/form-data 不对字符编码 在对文件上传时必须使用该值，js 构建 FormData 对象，上传</p><p>application/json json 格式数据提交</p><p>text/xml 提交 xml 格式数据</p><h2 id="request-method" tabindex="-1"><a class="header-anchor" href="#request-method" aria-hidden="true">#</a> Request Method</h2><p>GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</p><ul><li><p>PUT 是修改了整条记录，不变的字段也重写，PATCH 只是修改一个字段 局部修改</p></li><li><p>OPTIONS: 询问服务器支持的方法。当浏览器发现，是一个非简单请求，就自动发出一个&quot;预检&quot;请求，&quot;预检&quot;请求用的请求方法是 OPTIONS</p></li><li><p>当 header 的 content-type 类型是以下类型时不触发 options</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li></ul><h2 id="定时器" tabindex="-1"><a class="header-anchor" href="#定时器" aria-hidden="true">#</a> 定时器</h2>`,95),h={href:"http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html",target:"_blank",rel:"noopener noreferrer"},m=t('<p>setTimeout()</p><p>setInterval()</p><p>setImmediate()</p><p>process.nextTick() 是在本轮循环执行的，所有异步任务里最先执行的</p><ol><li>同步任务比异步任务早执行</li><li>异步任务 <ul><li>本轮循环（event loop，js 处理异步任务的方式）</li><li>次轮循环</li><li>本轮循环早于次轮循环</li></ul></li></ol><p>process.nextTick()和 Promise()的回调函数追加在本轮循环，即同步任务一旦执行完，就开始执行。</p><p>setTimeout，setInterval，setImmediate 追加在次轮循环</p><h2 id="微任务" tabindex="-1"><a class="header-anchor" href="#微任务" aria-hidden="true">#</a> 微任务</h2><p>promise 的回调会进入异步任务的&quot;微任务&quot;队列</p><p>微任务队列追加在 process.nextTick 队列之后，也是属于本轮循环</p><blockquote><p>只有前一个队列执行完了之后才能执行下一个队列</p></blockquote><h2 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h2>',12),v={href:"https://yuchengkai.cn/docs/zh/frontend/browser.html#node-%E4%B8%AD%E7%9A%84-event-loop",target:"_blank",rel:"noopener noreferrer"},b=t('<p>事件初始化，会先完成下面事情：</p><p>同步任务</p><p>发出异步请求</p><p>规划定时器生效的时间</p><p>执行 process.nextTick()等等</p><hr><p>事件循环会无限次地执行，只有异步任务的回调函数队列清空了，才停止。</p><p>每一轮六个阶段依次执行</p><ol><li><p>timers: 执行 setTimeout 和 setInterval,他们设置的时间并不是准确的执行时间，而是到了事件后，尽快的执行，因为系统可能因为其它而被耽误 范围[1, 2147483647]，不在设为 1</p></li><li><p>I/O callbacks: 执行除了 close 事件，定时器和 setImmediate 的回调</p></li><li><p>idle, prepare: idle, prepare 阶段内部实现</p></li><li><p>poll</p></li><li><p>check</p></li><li><p>close callbacks</p></li></ol><hr><h2 id="包学习" tabindex="-1"><a class="header-anchor" href="#包学习" aria-hidden="true">#</a> 包学习</h2><ul><li>child_process 参见 <code>node-koa/practice/</code></li></ul><h2 id="express" tabindex="-1"><a class="header-anchor" href="#express" aria-hidden="true">#</a> express</h2><p>var express=require(express);</p><p>var app=express();启动一个 web 服务器，将实例赋值给一个变量叫 app</p><p>express()是 express 模块导出的一个入口函数。</p><hr><h2 id="koa" tabindex="-1"><a class="header-anchor" href="#koa" aria-hidden="true">#</a> koa</h2><ul><li>koa-static 当设置的目录下有 index.html, 访问根路径时，会默认渲染 index.html</li><li>koa-multer 处理上传的文件</li><li>koa-bodyparser 解析上传的 json(基本)</li><li>使用 koa2-cors 时 要把 app.use(cors())放在最前面</li><li>中间件中有 next 会先执行它之前的代码，执行完最后一个中间件后会逆序执行各个中间件 next 之后的代码</li></ul><h3 id="graphql-实现" tabindex="-1"><a class="header-anchor" href="#graphql-实现" aria-hidden="true">#</a> graphql 实现</h3><ul><li><p>安装 apollo-server-koa 和 koa，看提示再安装 graphql</p></li><li><p>是一个用于 API 的查询语言，通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段提供解析函数</p></li></ul><hr><h3 id="koa-router" tabindex="-1"><a class="header-anchor" href="#koa-router" aria-hidden="true">#</a> koa-router</h3><ul><li>/page/:id 利用 ctx.params.id 获取</li></ul><h3 id="request" tabindex="-1"><a class="header-anchor" href="#request" aria-hidden="true">#</a> request</h3><ul><li>ctx.request.query：获取 query string 参数 以{ key:value } 形式返回</li></ul>',26);function g(f,x){const e=l("router-link"),o=l("ExternalLinkIcon");return c(),r("div",null,[n("nav",d,[n("ul",null,[n("li",null,[s(e,{to:"#node-与-deno-异同"},{default:p(()=>[a("node 与 Deno 异同")]),_:1})]),n("li",null,[s(e,{to:"#后端认证方式"},{default:p(()=>[a("后端认证方式：")]),_:1})]),n("li",null,[s(e,{to:"#npm-shrinkwrap-json-和-package-lock-json-区别"},{default:p(()=>[a("npm-shrinkwrap.json 和 package-lock.json 区别")]),_:1})]),n("li",null,[s(e,{to:"#package-json"},{default:p(()=>[a("package.json")]),_:1})]),n("li",null,[s(e,{to:"#模块的分类"},{default:p(()=>[a("模块的分类")]),_:1})]),n("li",null,[s(e,{to:"#基础知识"},{default:p(()=>[a("基础知识")]),_:1})]),n("li",null,[s(e,{to:"#常见的-content-type"},{default:p(()=>[a("常见的 Content-Type")]),_:1})]),n("li",null,[s(e,{to:"#request-method"},{default:p(()=>[a("Request Method")]),_:1})]),n("li",null,[s(e,{to:"#定时器"},{default:p(()=>[a("定时器")]),_:1})]),n("li",null,[s(e,{to:"#微任务"},{default:p(()=>[a("微任务")]),_:1})]),n("li",null,[s(e,{to:"#事件循环"},{default:p(()=>[a("事件循环")]),_:1})]),n("li",null,[s(e,{to:"#包学习"},{default:p(()=>[a("包学习")]),_:1})]),n("li",null,[s(e,{to:"#express"},{default:p(()=>[a("express")]),_:1})]),n("li",null,[s(e,{to:"#koa"},{default:p(()=>[a("koa")]),_:1}),n("ul",null,[n("li",null,[s(e,{to:"#graphql-实现"},{default:p(()=>[a("graphql 实现")]),_:1})]),n("li",null,[s(e,{to:"#koa-router"},{default:p(()=>[a("koa-router")]),_:1})]),n("li",null,[s(e,{to:"#request"},{default:p(()=>[a("request")]),_:1})])])])])]),k,n("p",null,[n("a",h,[a("参考"),s(o)])]),m,n("p",null,[n("a",v,[a("https://yuchengkai.cn/docs/zh/frontend/browser.html#node-%E4%B8%AD%E7%9A%84-event-loop"),s(o)])]),b])}const _=i(u,[["render",g],["__file","node.html.vue"]]);export{_ as default};

import{_ as s,M as t,p as d,q as r,R as a,N as i,V as l,t as n,a1 as u}from"./framework-7e1a102e.js";const c={},o={class:"table-of-contents"},p=u(`<p>[toc]</p><hr><h2 id="java" tabindex="-1"><a class="header-anchor" href="#java" aria-hidden="true">#</a> java</h2><ul><li><p>T 表示任意类型</p></li><li><p>用泛型不需要强转，减少了用object时产生的装箱拆箱操作，性能更好</p></li><li><p>双引号表示字符串；单引号表示字符，返回ascii码，可与数字进行运算</p></li><li><p>包声明；在包文件头部 <code>package xxx</code></p></li></ul><h3 id="执行" tabindex="-1"><a class="header-anchor" href="#执行" aria-hidden="true">#</a> 执行</h3><ol><li>编译 <code>javac Hello.java</code></li><li>执行 Hello.class 使用 <code>java Hello</code></li></ol><h3 id="语法相关" tabindex="-1"><a class="header-anchor" href="#语法相关" aria-hidden="true">#</a> 语法相关</h3><ul><li>语句后面注意加分号</li></ul><h4 id="关键字" tabindex="-1"><a class="header-anchor" href="#关键字" aria-hidden="true">#</a> 关键字</h4><ul><li>java 关键字区分大小写</li></ul><h4 id="标识符" tabindex="-1"><a class="header-anchor" href="#标识符" aria-hidden="true">#</a> 标识符</h4><ul><li>给变量， 类，方法等命名的符号</li><li>数字，字母，下划线，$，组成，不能以数字开头</li><li>严格区分大小写</li></ul><h4 id="变量" tabindex="-1"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h4><ul><li>区分大小写</li><li>变量类型 变量名 = 变量值</li><li>先申明，后使用</li></ul><h4 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h4><ul><li>java是强类型</li></ul><ol><li>基本数据类型(括号中的值为字节数)</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>|-- 数值型  
    |-- 整数：byte(1)，short(2)，int(4)，long(8)
    |-- 浮点：float(4)数字后添加字母f， double(8)
|-- 字符型 char(2) 用单引号 只能是一个字符
|-- 布尔型 boolean(1)  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>int 默认初始值：0</p></li><li><p>基本类型包装类(与基本类型之间可以自动转换)： 包装类型默认为NULL</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 所有包装类 Byte Short Integer Long Float Double Character Boolean BigInteger BigDecmail</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> n1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
<span class="token keyword">float</span> n2 <span class="token operator">=</span> n1<span class="token punctuation">.</span><span class="token function">floatValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>基本类型转换为字符串 <ul><li>使用 基本类型的封装类的 toString() 方法</li><li>使用 String 类的 valueOf() 方法</li><li>利用与 空字符串相加</li></ul></li><li>字符串转基本类型 <ul><li>包装类.parseXxx(xx)</li><li>包装类.valueOf(xx)</li></ul></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int num = 12;
System.out.println(Integer.toString(num));
System.out.println(String.valueOf(num));
System.out.println(num + &quot;&quot;);

String s = &quot;12.36&quot;;
Double db = Double.parseDouble(s);
Double dd = Double.valueOf(s);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>引用类型</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>|-- 类
|-- 接口
|-- 数组
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>float与double的区别：</p><ul><li>float占4字节，32位(但有9位要拿来放符号位和指数位)，最大数 8388608 最多7位，但只能保证6位精准</li><li>double 位数部分52位 最大数2^52 4503599627370496 精度15-16位</li><li>double消耗内存是float的两倍，double的运算速度比float慢</li></ul><h5 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h5><ul><li>两种方式： <code>String str = &quot;&quot;</code> 或 <code>String str = new String(&quot;&quot;)</code></li><li>引用数据类型 ；是字符串，用双引号</li><li>位于java.lang包中，默认自动引入所有的程序</li><li>每次创建一个字符串都是新对象</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>String s1 = &quot;字符串&quot;;
String s2 = &quot;字符串&quot;;
String s3 =  new String(&quot;字符串&quot;);
s1 和 s2 相等 因为多次出现的字符常量，java编译时只创建一个
s1，s2 和 s3 是不同的对象
s1 存放的是指向 &quot;字符串&quot;对象存在于堆内存中的地址
s1.equals(s3)  返回true；equals只比较内容
== 比较的是内存地址
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序中频繁操作字符串，就会产生很多的临时变量，使用<code>StringBuilder</code> 和 <code>StringBuffer</code> 就不会出现该问题；二者基本相似，不同在于 <code>StringBuilder</code>是线程安全的， <code>StringBuilder</code>没有实现但性能更高；所以一般情况下创建内容可变字符串，优先考虑 <code>StringBuilder</code></p><h5 id="自动类型转换" tabindex="-1"><a class="header-anchor" href="#自动类型转换" aria-hidden="true">#</a> 自动类型转换</h5><ol><li>两种类型要相互兼容</li><li>目标类型要大于源类型</li></ol><h5 id="强制类型转换" tabindex="-1"><a class="header-anchor" href="#强制类型转换" aria-hidden="true">#</a> 强制类型转换</h5><p>语法：(要转化为的数据类型)值</p><h4 id="运算符" tabindex="-1"><a class="header-anchor" href="#运算符" aria-hidden="true">#</a> 运算符</h4><ul><li>算术运算符</li></ul><p><code>+ - * / % ++ --</code></p><ul><li>% 用来求余数，也称为”取模运算符</li></ul><hr><ul><li>赋值运算符 <code>= += -= += /= %=</code></li></ul><hr><ul><li>比较运算符 <code>&gt; &lt; &gt;= &lt;= </code> 两边的操作数是数值类型</li></ul><p><code> == !=</code> 两边既可以是数值类型也可以是引用类型</p><hr><ul><li>逻辑运算符 <code>&amp;&amp; || !</code></li></ul><p><code>^</code> 有且必须一个为true一个为false</p><ul><li>条件运算符</li></ul><p><code>? :</code> 三元运算符</p><h4 id="条件语句" tabindex="-1"><a class="header-anchor" href="#条件语句" aria-hidden="true">#</a> 条件语句</h4><h5 id="swith" tabindex="-1"><a class="header-anchor" href="#swith" aria-hidden="true">#</a> swith</h5><ul><li><p>switch后的值必须是整形或字符型</p></li><li><p>case后面的可以使常量也可以是常量表达式</p></li><li><p>匹配后，只有遇到break或语句结束，才会停止执行，否则会执行下一个case中的值</p></li></ul><h5 id="for-循环变量初始化-循环条件-循环变量变化" tabindex="-1"><a class="header-anchor" href="#for-循环变量初始化-循环条件-循环变量变化" aria-hidden="true">#</a> for(循环变量初始化;循环条件;循环变量变化) {}}</h5><ol><li>循环变量初始化在循环中只执行一次</li><li>进行循环条件的判断，为真执行循环体</li><li>改变循环变量的值</li><li><code>2 -&gt; 3 -&gt;4 </code></li></ol><ul><li>括号中的三个表达式可以省略但是分号不能省略</li><li>循环变量初始化和循环变量变化，可以用逗号隔开</li><li>break continue</li></ul><h5 id="foreach" tabindex="-1"><a class="header-anchor" href="#foreach" aria-hidden="true">#</a> foreach</h5><p>遍历数组，集合 语法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>for(类型 xxx: 遍历对象) {
  print(xxx)
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h4><ul><li><p>声明：</p><ol><li>类型[] xxx;</li><li>类型 xxx[];</li></ol></li><li><p>分配空间 xxx = new 类型[ 长度]</p></li></ul><p>合并以上： <code>int[] xxx = new int[ 3]</code></p><ul><li>赋值</li></ul><p><code>xxx[ 1] = xx</code></p><p><code>int[] xxx = { 11, 12, 13 }</code> 等同于 <code>int[] xxx = new int[ 不能有长度]{ 11, 12, 13 }</code></p><ul><li>工具方法Arrays的使用</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;sports&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;game&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;movie&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;all name:&quot;</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="二维数组" tabindex="-1"><a class="header-anchor" href="#二维数组" aria-hidden="true">#</a> 二维数组</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- 声明：int[][] arr = new int[2][3] 或者  int[][] arr ={{1,2,3},{4,5,6}}

- 赋值只能具体到某个值进行操作： arr[1] = {1,3,3}; arr = {{1,3,3}, {1,4,3}} 报错
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h4><p>语法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>访问修饰符 返回值类型 方法名(类型) {
  方法体
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>访问修饰符：public, protected, private,或省略</li><li>返回值类型：没有返回值用void</li></ul><h5 id="方法重载" tabindex="-1"><a class="header-anchor" href="#方法重载" aria-hidden="true">#</a> 方法重载</h5><ul><li>同一个类中</li><li>相同的方法名</li><li>方法的参数个数，顺序，类型不同</li><li>与方法的修饰符，返回值没有关系</li></ul><h2 id="类" tabindex="-1"><a class="header-anchor" href="#类" aria-hidden="true">#</a> 类</h2><ol><li>所有java程序都是以类为组织单元</li><li>定义类（定义类名，定义属性，定义方法）</li></ol><h3 id="对象" tabindex="-1"><a class="header-anchor" href="#对象" aria-hidden="true">#</a> 对象</h3><ul><li>类是对象的类型</li><li>创建对象 <code>类名 对象名 = new 构造方法()</code></li><li>使用对象 对象名加调用</li></ul><h3 id="成员变量和局部变量" tabindex="-1"><a class="header-anchor" href="#成员变量和局部变量" aria-hidden="true">#</a> 成员变量和局部变量</h3><p>成员变量：在类中定义，描述对象将要有什么 局部变量：类的方法中定义，方法中保存临时数据</p><ul><li>只会给成员变量初始值</li><li>成员变量和局部变量同名，遵循就近原则</li></ul><h3 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> 构造方法</h3><ul><li>new 构造方法 创建新对象</li><li>定义用来初始化对象的方法，构造方法与类同名且没有返回值</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public 构造方法名(参数) {
  
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>没有指定无参的构造方法，系统会自动生成一个，也可以自己写无参构造方法</li><li>有参数构造方法</li></ul><h4 id="静态变量" tabindex="-1"><a class="header-anchor" href="#静态变量" aria-hidden="true">#</a> 静态变量</h4><ul><li><p>在类中定义</p></li><li><p>用static修饰，它属于整个类所有，而不是某个对象所有；可以直接用类名进行访问</p></li><li><p>static可修饰变量、方法、代码块</p></li></ul><h4 id="final-关键字" tabindex="-1"><a class="header-anchor" href="#final-关键字" aria-hidden="true">#</a> final 关键字</h4><p>语法 ： final xxx</p><ol><li>修饰类 类不可继承</li><li>修饰方法 方法不可覆盖</li><li>修饰属性 只可以在初始化时赋值一次</li></ol><p>子类构造方法中，没有显示调用父类的构造方法。则系统默认调用父类午餐的构造方法</p><p>Object类是所有类的父类</p><ul><li>toString() 方法重写</li><li>equals 比较对象的引用地址是否相同</li></ul><h4 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h4><p>同一个接口，使用不同的实例，执行不同的操作</p><ol><li><p>引用的多态 父类的引用指向子类的对象 父类的引用指向本类的对象 <code>Parent p = new Child();</code></p></li><li><p>继承</p></li><li><p>重写,子类重写父类方法</p></li></ol><p>不能使用子类的特有的属性和方法，强制转换：<code>Tiger tg = (Tiger) am;</code> 后即可访问</p><p>tg 指向最开始在堆内存中创建的那个 Tiger类型的对象</p><p>减少了多余对象的创建</p><h2 id="uml-统一建模语言" tabindex="-1"><a class="header-anchor" href="#uml-统一建模语言" aria-hidden="true">#</a> UML 统一建模语言</h2><p>图形话语言</p><ol><li>用例图</li><li>序列图： 按照交互，发生的一系列顺序</li><li>类图</li></ol><h2 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Throwable 类 java中所有不正常类都继承于它
  -- Error: 虚拟机错误，线程死锁，一般出现 程序就挂了
  -- Exception：编码、环境、用户操作输入出现问题
     -- RuntimeException：非检查异常，数组越界，引用空对象的属性或方法，等等；由虚拟机自动抛出并捕获。
         -- NullPointerException(空指针异常) \`String a = null;print(a.length())\`
         -- ArrayIndexOutOfBoundsException(数组下标越界)
         -- ClassCastException(类型转换异常)
         -- ArithmeticExceptior(算术异常) \`1/0\`
     -- 其它：检查异常；手动添加捕获，以及处理语句
         -- IOException(文件异常)
         -- SQLException(SQL异常)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>catch 多异常捕获，从子类到父类捕获</p></li><li><p>finally语句中去释放占用的资源</p></li><li><p>抛出异常：throw</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>throws 声明将要抛出何种类型的异常
如下是将错误抛出给更上一层的tryCatch，否则就直接在内部写tryCatch
public void 方法名(参数列表) throws Exception {
  // 调用会抛出异常的方法或
  throw new Exception(&quot;异常说明&quot;);
} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>自定义异常 继承Exception</li></ul><h2 id="时间处理" tabindex="-1"><a class="header-anchor" href="#时间处理" aria-hidden="true">#</a> 时间处理</h2><ul><li>将 Calendar 转换为 Date 使用 getTime()</li><li>getTimeInMillis() 获取 Calendar 的时间值，以毫秒为单位</li></ul><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h2><ul><li>集合中元素可以是任意类型的对象的引用</li><li>在类的内部对数据进行组织</li><li>简单快捷的搜索大数量的条目</li><li>有些集合提供了一系列有序的元素，可以在序列中快速的插入或删除有关元素</li><li>有些集合，提供了映射关系，可以通过关键字去快速查找唯一对象，这个关键字可以是任意类型</li><li>集合长度可变</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Collection-- List  排列有序，可重复
             -- ArrayList(数组序列) 
          -- Queue 排列有序，可重复
             -- LinkedList(链表)
          -- Set 无序，不可重复
             == HashSet(哈希集)
存储的是一个一个的对象

Map -- HashMap(哈希表)
映射关系，键值对
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>hashMap.values() 返回集合包含的值</li></ul><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h3><ul><li>调用contains方法，遍历list中的每一个元素，再调用每一个元素的equals方法，与传入的参数比较</li></ul><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set：</h3><ul><li>Set 中没有 get 方法</li><li>循环Set 每次的结果循序不一致</li><li>调用 contains 时，先调用每一个元素的 hashCode 方法返回hash码，如果hash码相同，再调用equals判断是否相等。都相等才相等</li></ul><h3 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map:</h3><ul><li>元素为键值对 key-value</li><li>键值对以Entry类型的对象形式存在</li><li>key不可重复 value可以</li><li>Map接口提供了返回key值集合，value值集合以及Entry集合的方法</li><li>支持泛型，<code>Map&lt; key类型, value类型&gt;</code></li></ul><h4 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h4><ul><li>是Map的一个重要实现类，</li><li>其中的Entry对象是无序列的</li><li>key和value都可以为null</li></ul><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h2><ul><li>规定了某个集合只可以存放特定类型的对象，会在编译期间进行类型检测</li><li>泛型集合不能添加除泛型及其子类型以外的对象，否则会报错</li><li>不能是基本类型，要用基本类型，要使用包装类</li></ul><h3 id="hashmap-1" tabindex="-1"><a class="header-anchor" href="#hashmap-1" aria-hidden="true">#</a> HashMap</h3><ul><li>ConcurrentHashMap 解决其在多线程编程中是线程不安全的，而Hashtable由于使用了synchronized修饰方法而导致执行效率不高</li></ul>`,124);function h(v,m){const e=t("router-link");return d(),r("div",null,[a("nav",o,[a("ul",null,[a("li",null,[i(e,{to:"#java"},{default:l(()=>[n("java")]),_:1}),a("ul",null,[a("li",null,[i(e,{to:"#执行"},{default:l(()=>[n("执行")]),_:1})]),a("li",null,[i(e,{to:"#语法相关"},{default:l(()=>[n("语法相关")]),_:1})])])]),a("li",null,[i(e,{to:"#类"},{default:l(()=>[n("类")]),_:1}),a("ul",null,[a("li",null,[i(e,{to:"#对象"},{default:l(()=>[n("对象")]),_:1})]),a("li",null,[i(e,{to:"#成员变量和局部变量"},{default:l(()=>[n("成员变量和局部变量")]),_:1})]),a("li",null,[i(e,{to:"#构造方法"},{default:l(()=>[n("构造方法")]),_:1})])])]),a("li",null,[i(e,{to:"#uml-统一建模语言"},{default:l(()=>[n("UML 统一建模语言")]),_:1})]),a("li",null,[i(e,{to:"#异常处理"},{default:l(()=>[n("异常处理")]),_:1})]),a("li",null,[i(e,{to:"#时间处理"},{default:l(()=>[n("时间处理")]),_:1})]),a("li",null,[i(e,{to:"#集合"},{default:l(()=>[n("集合")]),_:1}),a("ul",null,[a("li",null,[i(e,{to:"#list"},{default:l(()=>[n("List")]),_:1})]),a("li",null,[i(e,{to:"#set"},{default:l(()=>[n("Set：")]),_:1})]),a("li",null,[i(e,{to:"#map"},{default:l(()=>[n("Map:")]),_:1})])])]),a("li",null,[i(e,{to:"#泛型"},{default:l(()=>[n("泛型")]),_:1}),a("ul",null,[a("li",null,[i(e,{to:"#hashmap-1"},{default:l(()=>[n("HashMap")]),_:1})])])])])]),p])}const x=s(c,[["render",h],["__file","grammar.html.vue"]]);export{x as default};

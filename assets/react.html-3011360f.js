import{_ as o,M as p,p as l,q as i,R as n,N as s,V as e,t,a1 as c}from"./framework-7e1a102e.js";const r={},u={class:"table-of-contents"},d=c(`<p>[toc]</p><hr><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h2><ul><li>React.Component React.PureComponent 区别</li></ul><p>PureComponent 通过 props 和 state 的 浅对比实现 shouldComponentUpdate；前者需要自己实现</p><hr><ul><li><p>当input设置了value，但是没有设置onChange时会报错，可设置defaultValue或把onChange事件加上</p></li><li><p>ReactDOM.render(&lt; div&gt;当要添加多个标签时要用div包含在内&lt;/ div&gt;,容器元素对象)</p></li><li><p>jsx中写js的代码用{}括起来；之外可以正常用；</p></li><li><p>react推荐使用内联样式</p></li><li><p>img <strong>引入图片</strong></p><ol><li>css 设置背景图</li><li>src=&quot;require(&#39;xx/xx/x.jpg&#39;)&quot; // 该方式在最新的 create-react-app 脚手架搭建的项目中已经不能使用 ，使用方式以脚手架或自己搭建的项目方式为准</li><li>import logo from &#39;./public/logo.png&#39;; // create-react-app 可用</li></ol></li></ul><hr><ul><li><p>React.createElement(标签名|函数组件|class组件, { ...props }, children)</p></li><li><p>React.cloneElement(createElement创建的元素)</p></li><li><p>react 严格模式 StrictMode, 用了antd 后，会报错，删除严格模式即可</p></li></ul><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>React.StrictMode</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>App</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>React.StrictMode</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><ul><li>HOC: 参见 react-admin ；（与公共组件区别，主要是公共组件应该是多地方引用相同的组件，而不需要修改公共组件内容）</li></ul><hr><ul><li>在 create-react-app 中使用 装饰器：</li></ul><ol><li>npm run eject</li><li>配置babel</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&quot;plugins&quot;: [
    [
        &quot;@babel/plugin-proposal-decorators&quot;, 这里的插件，create-react-app 已经安装
        {
            &quot;legacy&quot;: true
        }
    ]
]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>勾选 vscode 中的 typescript 配置 &quot;javascript.implicitProjectConfig.experimentalDecorators&quot;: true</li></ol><hr><h3 id="组件" tabindex="-1"><a class="header-anchor" href="#组件" aria-hidden="true">#</a> 组件</h3><p>组件中 this 两种方式调用当前组件</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 方式一：</span>
<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方式二：利用箭头函数</span>
<span class="token function-variable function">onChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>function component</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  <span class="token keyword">return</span> <span class="token operator">&lt;</span> h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span> props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span> <span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>es6语法</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Welcome</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">return</span> <span class="token operator">&lt;</span> h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span> <span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>组件类名必须大写，且只能包含一个顶层标签</p></li><li><p>通过this.props.属性名，来获取参数</p></li><li><p>属性名class要用 className，for要用htmlFor</p></li><li><p>复合组件要用div标签包含起来</p></li><li><p>this.props的属性与组件的属性一一对应，但是this.props.children例外，它表示组件的所有子节点，它会返回undefind，object，array类型的值，所以react提供了React.Children来处理它可以用React.Children.map()，来遍历就不用担心返回的是什么类型的值。</p></li></ul><hr><p><strong>ref和findDOMNode</strong></p><ul><li>在节点上设置ref属性，然后用this.refs.属性名即可获取到真实的节点</li><li>ref添加到Compoennt上获取的是Compoennt实例，添加到原生HTML上获取的是DOM</li><li>ReactDOM.findDOMNode，当参数是DOM，返回值就是该DOM（这个没啥卵用）；当参数是Component获取的是该Component render方法中的DOM，返回的都是DOM</li></ul><hr><p><strong>对于表单value</strong> 不能用this.props来获取，只能用event.target.value获取</p><hr><p><strong>组件的生命周期</strong> mounting：已插入真实的DOM<br> updating：正在被重新渲染<br> unmounting：已移除真实的DOM<br> will:函数在进入状态之前，did：函数在进入状态之后<br> componentWillMount()<br> componentDidMount()<br> componentWillUpdate(object nextProps, object nextState)<br> componentDidUpdate(object prevProps, object prevState)<br> componentWillUnmount()<br> Mounted：组件被render解析，生成对应DOM节点并被插入浏览器DOM结构的过程。<br> Update：mounted的组件被重新render的过程。<br> Unmounted：组件对应的DOM节点被从DOM结构中移除的过程。<br> 每一个状态都封装了相应的hook（钩子）函数</p><hr><p><strong>状态state</strong><br> 初始状态用getInitialState对象赋值<br> getInitialState:function(return {状态名:值})<br> 该对象可以用this.state获取<br> 用this.setState修改该对象，每次修改都会重新调用this.render方法重新渲染<br> 在渲染是修改了state或props会陷入死循环。</p><hr><p><strong>props和state</strong><br> props是不可以改变的</p><p>赋初值一般用于 props 未赋值，但又不能为 null 的情况</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>组件名.defaultProps = {
  key: value
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>组件的属性类型判断，验证props 使用 prop-types 库</p><h3 id="hook" tabindex="-1"><a class="header-anchor" href="#hook" aria-hidden="true">#</a> Hook</h3><p>实践代码： react-admin/src/pages/practice/hooks</p><ul><li>使函数组件拥有状态 useState</li><li>只能放到函数组件中，如（useParams）</li><li>复杂状态用 <code>useReducer()</code></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 必须放在函数内顶部</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span> val<span class="token punctuation">,</span> setVal <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#39;initValue&#39;</span><span class="token punctuation">)</span>  <span class="token comment">// 返回数组,第一个值是设置的值，第二个值是更新这个值的函数</span>

<span class="token comment">// 这里用数组 就是为了可以自己定义 state 和修改state函数的名字，如果用对象解构 名字就需要固定</span>

<span class="token function">setVal</span><span class="token punctuation">(</span><span class="token parameter">old</span> <span class="token operator">=&gt;</span> old<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 采用回调方式更新，更好，修改后 react 会自动渲染对应UI，不会将新的 state和旧的state 合并</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原理：全局维护了一个 workInProgressHook 变量，多个数据间是采用链式的通过 next 进行的串联结构，所以不能在判断，循环，嵌套中使用，否则破坏链式结构</p><p>拥有了生命周期的概念(对应关系):</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>constructor              -&gt; useState
getDerivedStateFromProps -&gt; useState 中的 update 函数
shouldComponentUpdate    -&gt; useMemo
render                   -&gt; 函数本身
componentDidMount        -&gt; useEffect
componentDidUpdate       -&gt; useEffect
componentWillUnmount     -&gt; useEffect 里返回的函数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="redux" tabindex="-1"><a class="header-anchor" href="#redux" aria-hidden="true">#</a> Redux</h2><p>Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。</p><p>参考示例： https://www.redux.org.cn/docs/basics/ExampleTodoList.html</p><hr><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><p>store<br> 保存数据的地方，可看成一个容器，整个应用只能有一个store<br> redux提供了createStore函数接收一个函数参数，返回新的store对象</p><hr><p>state<br> store对象包含了所有数据，如果想得到某个时点的数据就要对store生成快照，这种时点的数据结合就叫state<br> 当前时刻的state可以用store.getState()获得一个state对应一个view</p><hr><p>action<br> state的变化会导致view的变化，但是用户只能看到view，所以state的变化是view导致的， action就是view发出的通知，告知state要变了<br> action是一个对象，type属性是必须的，其它的随意<br> store.dispatch()是view发出action的唯一方法，可接受一个action对象作为参数。</p><hr><p>reducer<br> store接收到action后，必须给出一个新的state，view才会变化，这就是reducer过程。<br> reducer函数接收state和action参数，返回一个新的state。 简单的通过 switch 判断不同的 action 返回不同的state 通过 connect 连接多个reducer store.dispatch()方法会触发reducer的自执行</p><hr><p>subscribe<br> 可以用subscribe函数监听store，一旦state发生变化就自动执行这个函数，该方法返回一个函数，调用这个函数就可以接触监听。</p><h2 id="redux-toolkit" tabindex="-1"><a class="header-anchor" href="#redux-toolkit" aria-hidden="true">#</a> redux-toolkit</h2><p>教程 https://penueling.com/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98/react-react-redux-redix-toolkit-%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8/</p><ul><li>createSlice() 根据传递的参数自动生成相应的actionCreator和reducer函数 https://blog.csdn.net/ilovethesunshine/article/details/109627560</li></ul><h2 id="react-router" tabindex="-1"><a class="header-anchor" href="#react-router" aria-hidden="true">#</a> react-router</h2><p>react-router 和react-router-dom 只要引用一个就行了，不同之处就是后者比前者多出了 &lt; Link&gt; &lt; BrowserRouter&gt; 这样的 DOM 类组件。<br> 因此我们只需引用 react-router-dom 这个包就行了。当然，如果搭配 redux ，你还需要使用 react-router-redux。</p><ul><li><code>exact</code> 精准定位路由 匹配 &#39;/&#39; 跟路由时作用明显</li></ul><h2 id="create-react-app" tabindex="-1"><a class="header-anchor" href="#create-react-app" aria-hidden="true">#</a> create-react-app</h2><ul><li>修改端口： 创建 <code>.env</code> 文件</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>PORT=3006
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 eject 暴露出配置后 可以在 config/webpack.config.js 中配置 alias <code>&#39;@&#39;: path.resolve(__dirname, &#39;../src&#39;),</code></p><ul><li>修改端口号和关闭自动打开浏览器： <ul><li>修改package.json的&quot;start&quot; 值为： <code>set BROWSER=none&amp;&amp;set PORT=3800 reatc-scripts start</code></li><li>修改node_modules/af-webpack/lib/dev.js中的如下代码</li></ul></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">DEFAULT_PORT</span> <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">PORT</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">5656</span><span class="token punctuation">;</span> <span class="token comment">// 修改默认值</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> _openBrowser<span class="token punctuation">.</span>default<span class="token punctuation">)</span><span class="token punctuation">(</span>urls<span class="token punctuation">.</span>localUrlForBrowser<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注释该行</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,74);function v(k,m){const a=p("router-link");return l(),i("div",null,[n("nav",u,[n("ul",null,[n("li",null,[s(a,{to:"#react"},{default:e(()=>[t("React")]),_:1}),n("ul",null,[n("li",null,[s(a,{to:"#组件"},{default:e(()=>[t("组件")]),_:1})]),n("li",null,[s(a,{to:"#hook"},{default:e(()=>[t("Hook")]),_:1})])])]),n("li",null,[s(a,{to:"#redux"},{default:e(()=>[t("Redux")]),_:1}),n("ul",null,[n("li",null,[s(a,{to:"#基本概念"},{default:e(()=>[t("基本概念")]),_:1})])])]),n("li",null,[s(a,{to:"#redux-toolkit"},{default:e(()=>[t("redux-toolkit")]),_:1})]),n("li",null,[s(a,{to:"#react-router"},{default:e(()=>[t("react-router")]),_:1})]),n("li",null,[s(a,{to:"#create-react-app"},{default:e(()=>[t("create-react-app")]),_:1})])])]),d])}const h=o(r,[["render",v],["__file","react.html.vue"]]);export{h as default};
